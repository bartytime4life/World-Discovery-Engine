name: PR Labeler & Checklist Guard — Ultimate

on:
  pull_request_target:
    types: [opened, edited, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]
  workflow_dispatch: {}

# Avoid duplicate runs on quick successive updates
concurrency:
  group: pr-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: false

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: read
  statuses: write

env:
  # Required checklist items (case-insensitive, exact names)
  REQUIRED_CHECKLIST: >-
    Ethics|Reproducibility|Datasets|Tests|CI Green
  # Conventional Commits title regex
  CONVENTIONAL_TITLE: '^((build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test)(\([\w\-.\/]+\))?!?:\s.+)$'
  # Docs-only auto-approve threshold (total changed lines)
  SMALL_DOCS_MAX_LINES: "50"
  # Size label thresholds
  SIZE_S: "20"
  SIZE_M: "100"
  SIZE_L: "500"
  SIZE_XL: "2000"

jobs:
  label-and-validate:
    name: Label & Validate PR
    runs-on: ubuntu-latest
    # Allow re-run via comment "/recheck"
    if: github.event_name != 'issue_comment' || contains(github.event.comment.body, '/recheck')
    steps:
      - name: Extract PR context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const prNum = (context.payload.pull_request && context.payload.pull_request.number) || (context.payload.issue && context.payload.issue.number);
            if (!prNum) core.setFailed('No PR number found.');
            const pr = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNum });
            core.setOutput('number', String(prNum));
            core.setOutput('title', pr.data.title || '');
            core.setOutput('body',  pr.data.body  || '');
            core.setOutput('draft', pr.data.draft ? 'true' : 'false');
            core.setOutput('user', pr.data.user.login);
            core.setOutput('head', pr.data.head.ref);
            core.setOutput('base', pr.data.base.ref);
            core.setOutput('isFork', pr.data.head.repo.fork ? 'true' : 'false');
            core.setOutput('changedFiles', String(pr.data.changed_files || 0));
            core.setOutput('additions',    String(pr.data.additions || 0));
            core.setOutput('deletions',    String(pr.data.deletions || 0));

      - name: Fetch changed files
        id: files
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.ctx.outputs.number }}');
            const perPage = 100;
            const files = [];
            for (let page = 1; ; page++) {
              const { data } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: perPage,
                page
              });
              files.push(...data);
              if (data.length < perPage) break;
            }
            core.setOutput('json', JSON.stringify(files));
            core.setOutput('filenames', files.map(f => f.filename).join('\n'));

      - name: Compute labels from PR body/title/files
        id: labels
        uses: actions/github-script@v7
        with:
          script: |
            const title = (`${{ steps.ctx.outputs.title }}` || '').toLowerCase();
            const body  = (`${{ steps.ctx.outputs.body }}`  || '').toLowerCase();
            const files = JSON.parse(`${{ steps.files.outputs.json || '[]' }}`);

            const labels = new Set();

            // Content-based labels
            if (/(\bethics\b|\bsovereignty\b|\bmask(ing|ed)?\b)/.test(body)) labels.add('ethics');
            if (/\bdataset(s)?\b|\bdvc\b|\bdatasets\.md\b/.test(body)) labels.add('datasets');
            if (/\breproducibility\b|\bseed(s)?\b|\bdockerfile\b|\bpoetry\b/.test(body)) labels.add('reproducibility');
            if (/\bnotebook(s)?\b|\bkaggle\b/.test(body)) labels.add('notebooks');
            if (/\bcli\b|\btyper\b|\bmakefile\b/.test(body)) labels.add('cli');
            if (/\bci\b|\bgithub actions?\b|\bworkflow(s)?\b/.test(body)) labels.add('ci');

            // Title-based (Conventional Commit cues)
            if (title.startsWith('feat')) labels.add('feature');
            if (title.startsWith('fix'))  labels.add('bug');
            if (title.startsWith('perf')) labels.add('performance');
            if (title.startsWith('docs')) labels.add('docs');
            if (title.includes('refactor')) labels.add('refactor');

            // Path-based labels
            const addIfAny = (regex, label) => { if (files.some(f => regex.test(f.filename))) labels.add(label); };
            addIfAny(/^\.github\/workflows\//, 'ci');
            addIfAny(/^world_engine\/cli\.py|^world_engine\/.*\/cli\.py/, 'cli');
            addIfAny(/^notebooks\/|\.ipynb$/, 'notebooks');
            addIfAny(/^docs\/|\.md$/, 'docs');
            addIfAny(/^data\/|datasets\.md$/, 'datasets');
            addIfAny(/^world_engine\/|^configs\//, 'code');
            addIfAny(/^tests\//, 'tests');
            addIfAny(/^Dockerfile|^docker\/|^compose\.ya?ml$/, 'reproducibility');
            addIfAny(/^pyproject\.toml|^poetry\.lock|^requirements.*\.txt$/, 'reproducibility');
            addIfAny(/^\.github\/CODEOWNERS$/, 'governance');
            addIfAny(/^\.github\/|^SECURITY\.md$/, 'security');

            // Size label
            const additions = Number(`${{ steps.ctx.outputs.additions }}` || 0);
            const deletions = Number(`${{ steps.ctx.outputs.deletions }}` || 0);
            const delta = additions + deletions;
            const S = Number(process.env.SIZE_S || 20);
            const M = Number(process.env.SIZE_M || 100);
            const L = Number(process.env.SIZE_L || 500);
            const XL= Number(process.env.SIZE_XL|| 2000);
            let size = 'size/XS';
            if (delta > S && delta <= M) size = 'size/S';
            else if (delta > M && delta <= L) size = 'size/M';
            else if (delta > L && delta <= XL) size = 'size/L';
            else if (delta > XL) size = 'size/XL';
            labels.add(size);

            core.setOutput('labels', JSON.stringify([...labels]));

      - name: Apply labels
        if: steps.labels.outputs.labels != '[]'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = JSON.parse(`${{ steps.labels.outputs.labels }}`);
            if (labels.length) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(`${{ steps.ctx.outputs.number }}`),
                labels
              });
            }

      - name: Enforce Conventional Commit title
        id: titlecheck
        uses: actions/github-script@v7
        with:
          script: |
            const re = new RegExp(process.env.RE, 'i');
            const title = `${{ steps.ctx.outputs.title }}`.trim();
            const ok = re.test(title);
            core.setOutput('ok', ok ? 'true' : 'false');
            if (!ok) {
              core.warning(`PR title does not match Conventional Commits: "${title}"`);
            }
          env:
            RE: ${{ env.CONVENTIONAL_TITLE }}

      - name: Checklist guard (fail if required boxes not checked)
        id: checklist
        uses: actions/github-script@v7
        with:
          script: |
            const body = `${{ steps.ctx.outputs.body }}` || '';
            const required = `${{ env.REQUIRED_CHECKLIST }}`.split('|').map(s => s.trim());
            // Match '- [x] Name' (accept lower/upper X)
            const makeRx = (n) => new RegExp(`- \$begin:math:display$(x|X)\\$end:math:display$\\s*${n}\\b`, 'i');
            const missing = required.filter(name => !makeRx(name).test(body));
            core.setOutput('missing', JSON.stringify(missing));
            if (missing.length) {
              core.setFailed(`Missing required checklist items: ${missing.join(', ')}

Ensure your PR uses the provided template and check:
- Ethics (coords masking, sovereignty banner, license verification)
- Reproducibility (seeds, config logging, Docker/Poetry)
- Datasets (registry entries, no large binaries)
- Tests (unit/integration)
- CI Green`);
            }

      - name: Sticky comment with validation results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber    = Number(`${{ steps.ctx.outputs.number }}`);
            const missing     = JSON.parse(`${{ steps.checklist.outputs.missing || '[]' }}`);
            const titleOK     = `${{ steps.titlecheck.outputs.ok }}` === 'true';
            const additions   = Number(`${{ steps.ctx.outputs.additions }}` || 0);
            const deletions   = Number(`${{ steps.ctx.outputs.deletions }}` || 0);
            const filesChanged= Number(`${{ steps.ctx.outputs.changedFiles }}` || 0);
            const labelsJSON  = `${{ steps.labels.outputs.labels || '[]' }}`;
            const labels      = JSON.parse(labelsJSON);

            const header = `### PR Validation Summary`;
            const t = titleOK ? '✅ Title matches Conventional Commits' : '❌ Title not Conventional Commits';
            const m = (missing.length ? `❌ Missing checklist: ${missing.join(', ')}` : '✅ Checklist complete');
            const stats = `Δ Lines: +${additions}/-${deletions} • Files: ${filesChanged}`;
            const lab = labels.length ? `Labels: \`${labels.join('`, `')}\`` : 'Labels: _(none)_';

            const body = `${header}

${t}
${m}
${lab}

**Stats:** ${stats}

> Re-run checks by commenting \`/recheck\`.`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            const bot = comments.find(c => c.user.type === 'Bot' && c.body && c.body.startsWith('### PR Validation Summary'));
            if (bot) {
              await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: bot.id, body });
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body });
            }

      - name: Auto-approve trivial docs-only PRs
        if: >
          success() &&
          steps.titlecheck.outputs.ok == 'true' &&
          fromJSON(steps.labels.outputs.labels).includes('docs') &&
          !fromJSON(steps.labels.outputs.labels).includes('code') &&
          !fromJSON(steps.labels.outputs.labels).includes('tests') &&
          (github.event.pull_request && github.event.pull_request.changed_files <= 5) &&
          (github.event.pull_request && (github.event.pull_request.additions + github.event.pull_request.deletions) <= env.SMALL_DOCS_MAX_LINES)
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: Number(`${{ steps.ctx.outputs.number }}`),
              event: 'APPROVE',
              body: 'Auto-approved trivial docs-only PR (size threshold).'
            });

      - name: Request reviewers based on paths
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const files = JSON.parse(`${{ steps.files.outputs.json || '[]' }}`);
            const reviewers = new Set();
            const teamReviewers = new Set();

            const addIfAny = (regex, users=[], teams=[]) => {
              if (files.some(f => regex.test(f.filename))) {
                users.forEach(u => reviewers.add(u));
                teams.forEach(t => teamReviewers.add(t));
              }
            };

            // Example mapping — customize to your org/team handles
            addIfAny(/^\.github\/workflows\//, [], ['devops']);
            addIfAny(/^world_engine\//, ['core-owner'], []);
            addIfAny(/^notebooks\/|\.ipynb$/, ['data-science-owner'], []);
            addIfAny(/^docs\/|\.md$/, ['docs-owner'], []);
            addIfAny(/^tests\//, ['qa-owner'], []);

            const r  = [...reviewers];
            const tr = [...teamReviewers];
            if (r.length || tr.length) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: Number(`${{ steps.ctx.outputs.number }}`),
                  reviewers: r,
                  team_reviewers: tr
                });
              } catch (e) {
                core.warning(`Request reviewers failed: ${e.message}`);
              }
            }

  # Optional: fast responder to /recheck comments
  recheck:
    name: Recheck Comment Handler
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/recheck')
    steps:
      - name: React to comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
            // Nothing else to do — main job runs because of the job-level `if`